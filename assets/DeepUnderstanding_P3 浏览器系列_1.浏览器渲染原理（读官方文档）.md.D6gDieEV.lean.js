import{_ as e,c as u,a4 as i,G as n,w as s,j as t,a as r,B as d,o as a}from"./chunks/framework.vOILIgLK.js";const M=JSON.parse('{"title":"浏览器渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"DeepUnderstanding/P3 浏览器系列/1.浏览器渲染原理（读官方文档）.md","filePath":"DeepUnderstanding/P3 浏览器系列/1.浏览器渲染原理（读官方文档）.md"}'),g={name:"DeepUnderstanding/P3 浏览器系列/1.浏览器渲染原理（读官方文档）.md"},p={id:"步骤-9-合成-光栅化-raster-合成",tabindex:"-1"},b={id:"优化方案",tabindex:"-1"};function f(y,l,m,q,P,k){const o=d("font");return a(),u("div",null,[l[110]||(l[110]=i('<h1 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-label="Permalink to &quot;浏览器渲染原理&quot;">​</a></h1><p><a href="https://developer.chrome.com/blog/inside-browser-part1?hl=zh-cn" target="_blank" rel="noreferrer">https://developer.chrome.com/blog/inside-browser-part1?hl=zh-cn</a></p><h2 id="浏览器多进程多线程架构" tabindex="-1">浏览器多进程多线程架构 <a class="header-anchor" href="#浏览器多进程多线程架构" aria-label="Permalink to &quot;浏览器多进程多线程架构&quot;">​</a></h2>',3)),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[0]||(l[0]=[r("进程可以描述为应用的正在执行的程序。线程是指位于进程内并执行其进程程序的任何部分的线程。")])),_:1}),l[111]||(l[111]=i(`<h3 id="多进程架构-multi-process-architecture" tabindex="-1">多进程架构（Multi-Process Architecture） <a class="header-anchor" href="#多进程架构-multi-process-architecture" aria-label="Permalink to &quot;多进程架构（Multi-Process Architecture）&quot;">​</a></h3><p>Chrome 启动时会创建多个<strong>系统级别的进程（Processes）</strong>，彼此相互隔离，主要包括：</p><ul><li><strong>浏览器进程（Browser Process）</strong><ul><li>只有一个，负责整个浏览器的主控。</li><li>管理：地址栏、书签栏、标签页管理、网络请求调度、资源管理、用户界面、进程调度。</li><li>拥有主线程（UI线程）和IO线程等。</li></ul></li><li><strong>渲染进程（Renderer Process）</strong><ul><li>每个标签页（Tab）/iframe/网站可用独立进程（通常为每个站点一个）。</li><li>执行 HTML、CSS、JavaScript 解析、布局、绘制。</li><li>沙箱隔离，增强安全性。</li><li>从A页面里面打开一个新的页面B页面，而A页面和B页面又属于同一站点的话，A和B就共用一个渲染进程。</li></ul></li><li><strong>GPU进程（GPU Process）</strong><ul><li>处理页面和UI中的图形加速任务，如 WebGL、Canvas、视频播放等。</li></ul></li><li><strong>网络进程（Network Process）</strong><ul><li>负责网络请求、缓存、Cookie、下载。</li><li>早期属于浏览器进程，后独立出来以增强稳定性。</li></ul></li><li><strong>插件进程（Plugin Process）</strong>（已废弃或极少） <ul><li>用于运行 Flash 等插件。</li></ul></li></ul><table tabindex="0"><thead><tr><th>功能</th><th>进程名称</th><th>作用</th></tr></thead><tbody><tr><td>主控</td><td><strong>浏览器进程</strong></td><td>管理窗口、标签页、网络请求调度</td></tr><tr><td>网络</td><td><strong>网络进程</strong></td><td>发起 HTTP 请求、处理响应</td></tr><tr><td>渲染</td><td><strong>渲染进程</strong></td><td>解析 HTML/CSS/JS，绘制页面</td></tr><tr><td>脚本执行</td><td>渲染进程中的 <strong>主线程</strong>（JS 引擎）</td><td>执行 JS 脚本、处理事件</td></tr><tr><td>合成</td><td><strong>GPU 进程</strong></td><td>加速图层合成与绘制</td></tr><tr><td>插件</td><td><strong>插件进程</strong></td><td>已逐渐淘汰</td></tr></tbody></table><h3 id="_2-每个进程内的多线程-multi-threading" tabindex="-1">2. 每个进程内的多线程（Multi-Threading） <a class="header-anchor" href="#_2-每个进程内的多线程-multi-threading" aria-label="Permalink to &quot;2. 每个进程内的多线程（Multi-Threading）&quot;">​</a></h3><p>尤其是 <strong>渲染进程</strong> 内部，拥有多个线程：</p><ul><li><strong>主线程（UI Thread / Main Thread）</strong><ul><li>负责执行 JavaScript、解析 HTML/CSS、构建 DOM 和 CSSOM。</li><li>处理用户事件（点击、输入等）。</li><li>协调布局（Layout）和绘制（Paint）流程。</li><li>是最核心、最繁忙的线程。</li></ul></li><li><strong>合成线程（Compositor Thread）</strong><ul><li>负责将主线程生成的图层合成到屏幕上。</li><li>支持异步滚动、动画，尤其对页面流畅性和 GPU 加速有重要作用。</li><li>与 GPU 进程协同工作，提高性能。</li></ul></li><li><strong>光栅线程（Raster Thread / Rasterizer）</strong><ul><li>负责把绘图指令转化为位图（bitmap），即「栅格化」。</li><li>通常在 GPU 进程中执行，但也可能在 CPU 中由多个线程执行（如软件栅格化）。</li></ul></li><li><strong>工作线程（Worker Threads）</strong><ul><li><strong>Web Worker</strong>：用于执行与 UI 无关的 JavaScript 脚本。，避免阻塞主线程。</li><li><strong>Service Workers</strong>：拦截网络请求、缓存资源、支持离线功能。</li><li><strong>Worklet Threads</strong>：CSS Paint API、AudioWorklet 等使用。</li></ul></li><li><strong>预解析线程Script Streaming Thread</strong><ul><li>识别 <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;img&gt;</code> 等资源。</li><li>提前发起请求，提高网络并发利用率。</li><li>但<strong>不能执行代码或构建 DOM</strong>，那是主线程的事。</li><li>并发加载 + 主线程继续构建</li></ul></li><li><strong>定时器与调度线程</strong><ul><li>用于处理 <code>setTimeout</code>、<code>setInterval</code>、<code>requestIdleCallback</code> 等定时任务。</li><li>与任务调度器（Task Scheduler）共同工作，管理优先级和任务队列。</li></ul></li></ul><h2 id="浏览器地址栏输入url到页面渲染" tabindex="-1">浏览器地址栏输入URL到页面渲染 <a class="header-anchor" href="#浏览器地址栏输入url到页面渲染" aria-label="Permalink to &quot;浏览器地址栏输入URL到页面渲染&quot;">​</a></h2><blockquote><p>用户输入 URL</p><pre><code> ↓
</code></pre><p>浏览器进程 发起导航</p><pre><code> ↓
</code></pre><p>网络进程 发起请求 → 返回响应</p><pre><code> ↓
</code></pre><p>渲染进程（主线程）解析 HTML/JS/CSS</p><pre><code> ↓
</code></pre><p>生成 DOM/CSSOM → Render Tree → Layout → Paint</p><pre><code> ↓
</code></pre><p>绘图指令 → 栅格线程 → 位图</p><pre><code> ↓
</code></pre><p>合成线程 + GPU → 显示页面</p></blockquote><h3 id="步骤-1-用户输入-url-按下回车" tabindex="-1">步骤 1：用户输入 URL，按下回车 <a class="header-anchor" href="#步骤-1-用户输入-url-按下回车" aria-label="Permalink to &quot;步骤 1：用户输入 URL，按下回车&quot;">​</a></h3>`,10)),t("ul",null,[t("li",null,[l[4]||(l[4]=t("strong",null,"浏览器进程",-1)),t("ul",null,[l[2]||(l[2]=t("li",null,"判断是否需要导航、是否命中缓存。",-1)),l[3]||(l[3]=t("li",null,[r("交给"),t("strong",null,"网络进程"),r("发起 HTTP/HTTPS 请求。")],-1)),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[1]||(l[1]=[r("标签页角落会显示加载旋转图标")])),_:1})])])])]),l[112]||(l[112]=t("h3",{id:"步骤-2-网络请求发送与响应接收",tabindex:"-1"},[r("步骤 2：网络请求发送与响应接收 "),t("a",{class:"header-anchor",href:"#步骤-2-网络请求发送与响应接收","aria-label":'Permalink to "步骤 2：网络请求发送与响应接收"'},"​")],-1)),t("ul",null,[t("li",null,[l[13]||(l[13]=t("strong",null,"网络进程",-1)),t("ul",null,[l[12]||(l[12]=t("li",null,"建立 TCP/QUIC 连接，发送请求。",-1)),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[5]||(l[5]=[r("响应是 HTML 文件，则下一步是将数据传递给渲染程序进程；但如果是 ZIP 文件或其他文件，则表示它是下载请求，因此需要将数据传递给下载管理器。")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[6]||(l[6]=[r("统还会进行")])),_:1}),l[9]||(l[9]=r("[")),n(o,{style:{color:"rgb(26, 115, 232)"}},{default:s(()=>l[7]||(l[7]=[r("跨源读取锁定 (CORB)")])),_:1}),l[10]||(l[10]=r("](https://www.chromium.org/Home/chromium-security/corb-for-developers)**")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[8]||(l[8]=[r(" 检查，以确保敏感的跨网站数据不会进入呈现程序。")])),_:1}),l[11]||(l[11]=r("**"))])])])]),l[113]||(l[113]=i('<blockquote><p>步骤1 2 <a href="https://www.yuque.com/yuqueyonghuyabgor/stiomf/pbguapn16vnzg2sq" target="_blank" rel="noreferrer">https://www.yuque.com/yuqueyonghuyabgor/stiomf/pbguapn16vnzg2sq</a></p></blockquote><h3 id="步骤-3-创建或重用渲染进程" tabindex="-1">步骤 3：创建或重用渲染进程 <a class="header-anchor" href="#步骤-3-创建或重用渲染进程" aria-label="Permalink to &quot;步骤 3：创建或重用渲染进程&quot;">​</a></h3><p>谷歌官方介绍：</p><p><a href="https://developer.chrome.com/blog/inside-browser-part3?hl=zh-cn" target="_blank" rel="noreferrer">https://developer.chrome.com/blog/inside-browser-part3?hl=zh-cn</a></p><ul><li><strong>浏览器进程</strong><ul><li>检查当前标签页是否已有对应的渲染进程。</li><li>若无，创建新的渲染进程，并分配权限（Site Isolation）。</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2025/png/26456403/1746775954735-9795927f-be1f-4865-8966-74bfe7880a86.png" alt="" data-fancybox="gallery" loading="lazy"></p><h3 id="步骤-4-文档解析-html" tabindex="-1">步骤 4：文档解析（HTML） <a class="header-anchor" href="#步骤-4-文档解析-html" aria-label="Permalink to &quot;步骤 4：文档解析（HTML）&quot;">​</a></h3><ul><li><strong>渲染进程：主线程</strong><ul><li>逐行解析 HTML。</li><li>构建 DOM 树（Document Object Model）。</li><li>遇到 <code>&lt;script&gt;</code> 阻塞，执行 JS。</li><li>下载并解析 CSS，构建 CSSOM（CSS Object Model）。</li></ul></li></ul><h4 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h4><p><a href="https://www.yuque.com/yuqueyonghuyabgor/aa116g/ogafbv3u9s41a7po?singleDoc#" target="_blank" rel="noreferrer">https://www.yuque.com/yuqueyonghuyabgor/aa116g/ogafbv3u9s41a7po?singleDoc#</a> 《终极-浏览器加载资源顺序指南》</p><h5 id="html解析过程中遇到css代码" tabindex="-1">HTML解析过程中遇到css代码 <a class="header-anchor" href="#html解析过程中遇到css代码" aria-label="Permalink to &quot;HTML解析过程中遇到css代码&quot;">​</a></h5><p>HTML文档的解析，在解析前，预解析线程工作，率先发起请求下载HTML中外部的css、js文件。</p><p>开始逐行解析，遇到link标签，若此时该标签的css资源还没下载解析完成，主线程不会等待，会继续文档的解析，构建dom树，而css会在预解析线程中同步下载解析，完事后给到主线程，主线程生成cssom树<img src="https://cdn.nlark.com/yuque/0/2025/png/26456403/1746777300229-f8e91252-5859-43ab-8755-f1f3e3810ee4.png" alt="" data-fancybox="gallery" loading="lazy"></p><blockquote><p>css的加载不会直接阻塞html的解析，但是会阻塞js的执行，阻塞js的执行进而会阻塞html解析（css在script之前）</p><ul><li>js中可能会调用<code>getComputedStyle()</code>、读取 DOM 样式信息等，如果 CSS 没加载完成就执行，会导致样式不准确或闪烁。</li></ul></blockquote><h5 id="html解析过程中遇到js代码" tabindex="-1">HTML解析过程中遇到js代码<img src="https://cdn.nlark.com/yuque/0/2025/png/26456403/1746778197946-d9009855-a00e-4c20-bbbf-45a832f10304.png" alt="" data-fancybox="gallery" loading="lazy"> <a class="header-anchor" href="#html解析过程中遇到js代码" aria-label="Permalink to &quot;HTML解析过程中遇到js代码![](https://cdn.nlark.com/yuque/0/2025/png/26456403/1746778197946-d9009855-a00e-4c20-bbbf-45a832f10304.png)&quot;">​</a></h5><h6 id="同步js代码" tabindex="-1">同步js代码 <a class="header-anchor" href="#同步js代码" aria-label="Permalink to &quot;同步js代码&quot;">​</a></h6><p>继续解析，如果遇到了script标签，会停止解析，等js文件下载完成后，开始执行js文件，js执行完成之后，继续HTML解析</p><blockquote><p>js的下载我理解也是预解析线程中进行的，之所以会阻塞HTML解析，我理解根本原因是因为主线程要等js执行完成，因为</p><ul><li>js的执行可能会操作DOM</li><li>防止出现边构建边改动的情况，所以HTML主解析器必须停止，等js执行完，再继续构建DOM</li></ul></blockquote><h6 id="async-defer-参见文档" tabindex="-1">async defer 参见文档 <a class="header-anchor" href="#async-defer-参见文档" aria-label="Permalink to &quot;async  defer  参见文档&quot;">​</a></h6><p><a href="https://www.yuque.com/yuqueyonghuyabgor/aa116g/ogafbv3u9s41a7po?singleDoc#" target="_blank" rel="noreferrer">https://www.yuque.com/yuqueyonghuyabgor/aa116g/ogafbv3u9s41a7po?singleDoc#</a> 《终极-浏览器加载资源顺序指南》</p><h3 id="步骤-5-样式计算" tabindex="-1">步骤 5：样式计算 <a class="header-anchor" href="#步骤-5-样式计算" aria-label="Permalink to &quot;步骤 5：样式计算&quot;">​</a></h3>',21)),t("ul",null,[t("li",null,[l[17]||(l[17]=t("strong",null,"主线程",-1)),t("ul",null,[l[16]||(l[16]=t("li",null,"合并 DOM 和 CSSOM，进行样式计算",-1)),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[14]||(l[14]=[r("主线程会解析 CSS 并确定每个 DOM 节点的计算样式。")])),_:1}),l[15]||(l[15]=t("img",{src:"https://cdn.nlark.com/yuque/0/2025/png/26456403/1747034905526-9c95109f-4a4f-44f5-b089-72acc8ae522d.png",alt:"","data-fancybox":"gallery",loading:"lazy"},null,-1))])])])]),l[114]||(l[114]=t("h3",{id:"步骤-6-布局-layout-reflow-布局树",tabindex:"-1"},[r("步骤 6：布局（Layout / Reflow）布局树 "),t("a",{class:"header-anchor",href:"#步骤-6-布局-layout-reflow-布局树","aria-label":'Permalink to "步骤 6：布局（Layout / Reflow）布局树"'},"​")],-1)),t("ul",null,[t("li",null,[l[32]||(l[32]=t("strong",null,"主线程",-1)),t("ul",null,[t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[18]||(l[18]=[r("布局是查找元素几何图形的过程。主线程会遍历 DOM 和计算样式，并创建包含 x、y 坐标和边界框大小等信息的布局树。")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[19]||(l[19]=[r("布局树的结构可能与 DOM 树类似，但它仅包含与网页上显示的内容相关的信息。如果应用了 ")])),_:1}),l[26]||(l[26]=r("`")),n(o,{style:{color:"rgb(55, 71, 79)"}},{default:s(()=>l[20]||(l[20]=[r("display: none")])),_:1}),l[27]||(l[27]=r("`")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[21]||(l[21]=[r("，则该元素不属于布局树（不过，具有 ")])),_:1}),l[28]||(l[28]=r("`")),n(o,{style:{color:"rgb(55, 71, 79)"}},{default:s(()=>l[22]||(l[22]=[r("visibility: hidden")])),_:1}),l[29]||(l[29]=r("`")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[23]||(l[23]=[r(" 的元素属于布局树）。同样，如果应用了包含 ")])),_:1}),l[30]||(l[30]=r("`")),n(o,{style:{color:"rgb(55, 71, 79)"}},{default:s(()=>l[24]||(l[24]=[r('p::before{content:"Hi!"}')])),_:1}),l[31]||(l[31]=r("`")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[25]||(l[25]=[r(" 等内容的伪元素，即使该元素不在 DOM 中，也会包含在布局树中。")])),_:1})])])])]),l[115]||(l[115]=t("p",null,[t("img",{src:"https://cdn.nlark.com/yuque/0/2025/png/26456403/1747035007116-2f267cd6-a72f-4ec1-ab1a-a827d05b4af4.png",alt:"","data-fancybox":"gallery",loading:"lazy"})],-1)),l[116]||(l[116]=t("p",null,[t("img",{src:"https://cdn.nlark.com/yuque/0/2025/png/26456403/1746781319706-12f3c2e4-76d7-4772-901f-4c68fca15d2d.png",alt:"","data-fancybox":"gallery",loading:"lazy"})],-1)),l[117]||(l[117]=t("hr",null,null,-1)),l[118]||(l[118]=t("h3",{id:"步骤-7-分层与层树-layer-tree",tabindex:"-1"},[r("步骤 7：分层与层树（Layer Tree） "),t("a",{class:"header-anchor",href:"#步骤-7-分层与层树-layer-tree","aria-label":'Permalink to "步骤 7：分层与层树（Layer Tree）"'},"​")],-1)),t("ul",null,[t("li",null,[l[37]||(l[37]=t("strong",null,"主线程",-1)),t("ul",null,[t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[33]||(l[33]=[r("为了确定哪些元素需要位于哪些层中，主线程会遍历布局树以创建层树")])),_:1})]),l[34]||(l[34]=t("li",null,"检查哪些元素需要独立图层（如 transform、opacity）。",-1)),l[35]||(l[35]=t("li",null,"分层好处：将来某个层发生改变，仅对该层进行处理，提升效率",-1)),l[36]||(l[36]=t("li",null,"滚动条、堆叠上下文、transform\\opacity等样式都会过多过少的影响分层结果，也可以通过will-change属性更大程度影响分层结果",-1))])])]),l[119]||(l[119]=t("h3",{id:"步骤-8-绘制-paint",tabindex:"-1"},[r("步骤 8：绘制（Paint） "),t("a",{class:"header-anchor",href:"#步骤-8-绘制-paint","aria-label":'Permalink to "步骤 8：绘制（Paint）"'},"​")],-1)),t("ul",null,[t("li",null,[l[43]||(l[43]=t("strong",null,"主线程",-1)),t("ul",null,[t("li",null,[l[39]||(l[39]=r("将图层中的元素绘制为")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[38]||(l[38]=[r("paint records")])),_:1}),l[40]||(l[40]=r("，用来描述该层应该怎么画出来。"))]),l[41]||(l[41]=t("li",null,"完成绘制后，主线程将每个图层的绘制信息提交到合成线程、剩余工作由合成线程完成",-1)),l[42]||(l[42]=t("li",null,[t("img",{src:"https://cdn.nlark.com/yuque/0/2025/png/26456403/1747035530826-c263c340-91c3-4b1a-bdad-c248613c2a22.png",alt:"","data-fancybox":"gallery",loading:"lazy"})],-1))])])]),t("h3",p,[l[45]||(l[45]=r("步骤 9：合成：")),n(o,{style:{color:"rgb(36, 43, 52)"}},{default:s(()=>l[44]||(l[44]=[r("光栅化")])),_:1}),l[46]||(l[46]=r("（Raster）+ 合成 ")),l[47]||(l[47]=t("a",{class:"header-anchor",href:"#步骤-9-合成-光栅化-raster-合成","aria-label":'Permalink to "步骤 9：合成：<font style="color:rgb(36, 43, 52);">光栅化</font>（Raster）+ 合成"'},"​",-1))]),n(o,{style:{color:"rgb(36, 43, 52)"}},{default:s(()=>l[48]||(l[48]=[r("合成是一种将页面的各个部分分层、分别栅格化，然后在称为合成器线程的单独线程中合成为一个页面的技术。")])),_:1}),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[49]||(l[49]=[r("创建图层树并确定绘制顺序后，主线程会将这些信息提交给合成器线程。然后，合成程序线程会对每个图层进行光栅化处理。图层可能很大，例如整个网页的长度，因此合成程序线程会将其划分为图块，并将每个图块发送到光栅线程。光栅线程会对每个图块进行光栅化处理，并将其存储在 GPU 显存中。")])),_:1}),t("ul",null,[t("li",null,[t("strong",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[50]||(l[50]=[r("合成器线程")])),_:1})]),t("ul",null,[t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[51]||(l[51]=[r("创建图层树并确定绘制顺序后，主线程会将这些信息提交给合成器线程。")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[52]||(l[52]=[r("合成程序线程会将图层划分为图块，并将每个图块发送到光栅线程")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[53]||(l[53]=[r("合成器线程可以优先处理不同的光栅线程，以便先光栅化视口内（或附近）的内容")])),_:1})])])]),t("li",null,[l[57]||(l[57]=t("strong",null,"光栅线程 / GPU 进程",-1)),t("ul",null,[t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[54]||(l[54]=[r("光栅线程会对每个图块进行光栅化处理，并将其存储在 GPU 显存中。")])),_:1})]),l[55]||(l[55]=t("li",null,"将绘图命令转为位图（raster），准备上传到 GPU。",-1)),l[56]||(l[56]=t("li",null,"光栅化结果生成一块块的位图",-1))])]),t("li",null,[l[74]||(l[74]=t("strong",null,"合成线程 + GPU 进程",-1)),t("ul",null,[l[72]||(l[72]=t("li",null,"合成线程（Compositor Thread）计算最终合成顺序。",-1)),t("li",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[58]||(l[58]=[r("合成器线程会收集称为")])),_:1}),l[63]||(l[63]=r("**")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[59]||(l[59]=[r("绘制四边形")])),_:1}),l[64]||(l[64]=r("**")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[60]||(l[60]=[r("的图块信息，以创建")])),_:1}),l[65]||(l[65]=r("**")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[61]||(l[61]=[r("合成器帧")])),_:1}),l[66]||(l[66]=r("**")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[62]||(l[62]=[r("。")])),_:1})]),t("li",null,[t("strong",null,[n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[67]||(l[67]=[r("合成器帧")])),_:1})]),n(o,{style:{color:"rgb(32, 33, 36)"}}),l[68]||(l[68]=r("会标识出每个位图应该画到屏幕的那个位置，以及会考虑到旋转、缩放等变形"))]),l[73]||(l[73]=t("li",null,"变形发生在合成线程、与渲染主线程无关、所以transform效率高",-1)),t("li",null,[l[70]||(l[70]=r("合成线程会把合成器**")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[69]||(l[69]=[r("帧")])),_:1}),l[71]||(l[71]=r("**提交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件，完成屏幕成像"))])])])]),l[120]||(l[120]=i('<h2 id="渲染流程描述-白话版" tabindex="-1">渲染流程描述（白话版） <a class="header-anchor" href="#渲染流程描述-白话版" aria-label="Permalink to &quot;渲染流程描述（白话版）&quot;">​</a></h2><p>官网：</p><p><a href="https://developer.chrome.com/blog/inside-browser-part3?hl=zh-cn#style_calculation" target="_blank" rel="noreferrer">https://developer.chrome.com/blog/inside-browser-part3?hl=zh-cn#style_calculation</a></p><p>网络进程拉取html资源后，会产生一个渲染任务，并将其传递给渲染进程 -》 主线程的消息队列，在事件循环机制的作用下，渲染主线程从消息队列中取出任务，开启渲染流程；</p><p>渲染流程的主要步骤，html解析、样式计算、布局、分层、绘制、分块、光栅化、画。通过这个流水线完成页面的渲染。</p><p>第一步html解析：</p><p>渲染主线程进行html的解析，生成dom树（dom对象）</p><p>主线程完成cssom树的构建</p><p>主线程完成js代码的加载&amp;执行（各种情况）</p><p>第二步样式计算 ：</p><p>主线程会遍历得到的DOM树，依次为树中的节点计算他的最终样式，computed style，在这个过程中，很多预设值会变成绝对值，相对单位会变成绝对单位，完成后会得到一个携带样式的DOM树</p><p>第三步：布局</p>',12)),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[75]||(l[75]=[r("主线程会遍历 DOM 和计算样式，并创建包含 x、y 坐标和边界框大小等信息的布局树。布局树的结构可能与 DOM 树类似，但它仅包含与网页上显示的内容相关的信息。如果应用了 ")])),_:1}),l[121]||(l[121]=r("`")),n(o,{style:{color:"rgb(55, 71, 79)"}},{default:s(()=>l[76]||(l[76]=[r("display: none")])),_:1}),l[122]||(l[122]=r("`")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[77]||(l[77]=[r("，则该元素不属于布局树（不过，具有 ")])),_:1}),l[123]||(l[123]=r("`")),n(o,{style:{color:"rgb(55, 71, 79)"}},{default:s(()=>l[78]||(l[78]=[r("visibility: hidden")])),_:1}),l[124]||(l[124]=r("`")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[79]||(l[79]=[r(" 的元素属于布局树）。同样，如果应用了包含 ")])),_:1}),l[125]||(l[125]=r("`")),n(o,{style:{color:"rgb(55, 71, 79)"}},{default:s(()=>l[80]||(l[80]=[r('p::before{content:"Hi!"}')])),_:1}),l[126]||(l[126]=r("`")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[81]||(l[81]=[r(" 等内容的伪元素，即使该元素不在 DOM 中，也会包含在布局树中。")])),_:1}),l[127]||(l[127]=t("p",null,"第四步：分层",-1)),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[82]||(l[82]=[r("主线程会遍历布局树以创建层树")])),_:1}),l[128]||(l[128]=r("。")),l[129]||(l[129]=t("p",null,"分层好处：将来某个层发生改变，仅对该层进行处理，提升效率",-1)),l[130]||(l[130]=t("p",null,"滚动条、堆叠上下文、transform\\opacity等样式都会过多过少的影响分层结果，也可以通过will-change属性更大程度影响分层结果",-1)),l[131]||(l[131]=t("p",null,"第五步：绘制",-1)),t("p",null,[l[85]||(l[85]=r("主线程")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[83]||(l[83]=[r("遍历布局树以创建绘制记录")])),_:1}),l[86]||(l[86]=r("，完成绘制后，主线程将每个图层的绘制信息（")),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[84]||(l[84]=[r("文档的结构、每个元素的样式、网页的几何图形和绘制顺序")])),_:1}),l[87]||(l[87]=r("）提交到合成线程"))]),l[132]||(l[132]=t("p",null,"第六步：分块",-1)),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[88]||(l[88]=[r("合成程序线程会对每个图层进行光栅化处理。图层可能很大，例如整个网页的长度，因此合成程序线程会将其划分为图块，并将每个图块发送到光栅线程。")])),_:1}),l[133]||(l[133]=t("p",null,"第七步：光栅化",-1)),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[89]||(l[89]=[r("光栅线程会对每个图块进行光栅化处理，并将其存储在 GPU 显存中")])),_:1}),n(o,{style:{color:"rgb(32, 33, 36)"}},{default:s(()=>l[90]||(l[90]=[r("合成器线程可以优先处理不同的光栅线程，以便先光栅化视口内（或附近）的内容")])),_:1}),l[134]||(l[134]=i('<p>最后：画</p><p>合成线程收集图块信息，创建合成器帧，合成器帧发送到GPU进程，给GPU硬件，完成成像</p><h2 id="回流重绘" tabindex="-1">回流重绘 <a class="header-anchor" href="#回流重绘" aria-label="Permalink to &quot;回流重绘&quot;">​</a></h2><p><strong>（1）回流</strong><br> 回流 的本质就是重新计算 layout 树。<br> 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。<br> 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 回流 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。<br> 浏览器在反复权衡下，最终决定获取属性（比如 dom.clientWidth）立即 回流。</p><p><strong>（2）重绘</strong><br> 重绘 的本质就是重新根据分层信息计算了绘制指令。<br> 当改动了可见样式后，就需要重新计算，会引发 重绘。<br><strong>由于元素的布局信息也属于可见样式，所以 回流 一定会引起 重绘。</strong></p><p><strong>（3）最后总结</strong></p><ul><li><strong>回流</strong>（也叫重排）：当 DOM结构发生变化 或者 元素样式 发生改变时，浏览器需要重新计算样式和渲染树，这个过程比较消耗性能。</li><li><strong>重绘</strong>：指元素的外观样式发生变化（比如改变 背景色，边框颜色，文字颜色color等 ），但是布局没有变，此时浏览器只需要应用新样式绘制元素就可以了，比回流消耗的性能小一些。</li></ul><p><strong>回流必定会发生重绘，重绘却可以单独出现</strong> 。回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。</p><p>总之，对元素执行回流操作之后，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。</p><h3 id="引起回流" tabindex="-1">引起回流 <a class="header-anchor" href="#引起回流" aria-label="Permalink to &quot;引起回流&quot;">​</a></h3>',11)),t("ol",null,[t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[91]||(l[91]=[r("页面的首次渲染")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[92]||(l[92]=[r("浏览器的窗口大小发生变化")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[93]||(l[93]=[r("元素内容发生变化")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[94]||(l[94]=[r("元素的尺寸或位置发生变化")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[95]||(l[95]=[r("元素的字体大小发生变化")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[96]||(l[96]=[r("添加或删除可见的DOM元素")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[97]||(l[97]=[r("激活CSS伪类")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[98]||(l[98]=[r("查询某些属性或者调用某些方法")])),_:1})])]),t("h4",b,[n(o,{style:{color:"rgb(89, 89, 89)"}},{default:s(()=>l[99]||(l[99]=[r("优化方案：")])),_:1}),l[100]||(l[100]=r()),l[101]||(l[101]=t("a",{class:"header-anchor",href:"#优化方案","aria-label":'Permalink to "<font style="color:rgb(89, 89, 89);">优化方案：</font>"'},"​",-1))]),l[135]||(l[135]=i('<ul><li><strong>使用 CSS 动画代替 JavaScript 动画</strong>：CSS 动画利用 GPU 加速，在性能方面通常比 JavaScript 动画更高效。使用 CSS 的transform 和 opacity 属性来创建动画，而不是改变元素的布局属性，如宽度、高度等。</li><li><strong>使用 translated3d 开启硬件加速</strong>：将元素的位移属性设置为 translated3d( 0,0,0 )，可以强制使用 GPU 加速。有助于避免回流，并提高动画流畅度。</li><li><strong>避免频繁操作影响布局的样式属性</strong>：当需要对元素进行多次样式修改时，可以考虑将这些修改合并为一次操作。通过添加/移除 css类来一次性改变多个样式属性，而不是逐个修改。</li><li><strong>使用 requestAnimationFrame</strong>：通过使用 requestAnimationFrame 方法调度动画帧，可以确保动画在浏览器的重绘周期内执行，从而避免不必要的回流。这种方式可确保动画在最佳时间点进行渲染。</li><li><strong>使用文档片段（Document Fragment）</strong> ：当需要在 DOM 中插入大量新元素时，可以先将这些元素添加到文档片段中，然后再将整个文档片段一次性插入到 DOM 中。这样可以减少回流和重绘的次数。（vue 虚拟dom的做法）</li><li><strong>使元素脱离文档流</strong>：position: absolute/position: fixed/float:left（只是减少回流，不是避免回流）</li><li><strong>使用 visibility:hidden 代替 display: none</strong> ：visibility:hidden不会触发回流，因为元素仍然占据空间，只是不可见。而 display: none 会将元素从渲染树中移除，引起回流。</li><li>多样式调整的话，进行类的整合，隐藏后再处理</li></ul><h2 id="认识" tabindex="-1">认识 <a class="header-anchor" href="#认识" aria-label="Permalink to &quot;认识&quot;">​</a></h2><h3 id="cssom树" tabindex="-1">cssom树 <a class="header-anchor" href="#cssom树" aria-label="Permalink to &quot;cssom树&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/26456403/1746776842493-cfd125e7-62a6-4753-a803-1a5b95808199.png" alt="" data-fancybox="gallery" loading="lazy"></p><h3 id="domcontentload" tabindex="-1">DOMContentLoad <a class="header-anchor" href="#domcontentload" aria-label="Permalink to &quot;DOMContentLoad&quot;">​</a></h3>',5)),n(o,{style:{color:"rgb(102, 102, 102)","background-color":"rgb(248, 248, 248)"}},{default:s(()=>l[102]||(l[102]=[r("当初始的 HTML 文档被完全加载和解析完成之后（DOM tree生成前夕），DOMContentLoaded 事件被触发")])),_:1}),t("p",null,[t("strong",null,[n(o,{style:{color:"rgb(37, 41, 51)"}},{default:s(()=>l[103]||(l[103]=[r("html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都")])),_:1}),t("strong",null,[t("strong",null,[n(o,{style:{color:"rgb(37, 41, 51)","background-color":"#FBDE28"}},{default:s(()=>l[104]||(l[104]=[r("执行完毕")])),_:1})])]),n(o,{style:{color:"rgb(37, 41, 51)"}},{default:s(()=>l[105]||(l[105]=[r("后触发")])),_:1})]),n(o,{style:{color:"rgb(37, 41, 51)"}},{default:s(()=>l[106]||(l[106]=[r("。")])),_:1})]),l[136]||(l[136]=t("h3",{id:"load事件",tabindex:"-1"},[r("Load事件 "),t("a",{class:"header-anchor",href:"#load事件","aria-label":'Permalink to "Load事件"'},"​")],-1)),n(o,{style:{color:"rgb(37, 41, 51)"}},{default:s(()=>l[107]||(l[107]=[r("html 文档中的图片资源，js 代码中有异步加载的 css、js 、图片资源都加载完毕之后，load 事件触发。")])),_:1}),t("blockquote",null,[t("ul",null,[t("li",null,[n(o,{style:{color:"rgb(37, 41, 51)"}},{default:s(()=>l[108]||(l[108]=[r("页面中引用的js 代码如果有异步加载的 js、css、图片，是会影响 load 事件触发的。")])),_:1})]),t("li",null,[n(o,{style:{color:"rgb(37, 41, 51)"}},{default:s(()=>l[109]||(l[109]=[r("video、audio、flash 不会影响 load 事件触发。")])),_:1})])])])])}const x=e(g,[["render",f]]);export{M as __pageData,x as default};
