import{_ as t,c as a,a4 as n,o as i}from"./chunks/framework.vOILIgLK.js";const k=JSON.parse('{"title":"执行上下文（参考 ECMA2024）","description":"","frontmatter":{},"headers":[],"relativePath":"DeepUnderstanding/P1 JavaScript深入理解/1.JavaScript执行上下文（参考ECMA2024）.md","filePath":"DeepUnderstanding/P1 JavaScript深入理解/1.JavaScript执行上下文（参考ECMA2024）.md"}'),r={name:"DeepUnderstanding/P1 JavaScript深入理解/1.JavaScript执行上下文（参考ECMA2024）.md"};function s(o,e,l,c,p,h){return i(),a("div",null,e[0]||(e[0]=[n(`<h1 id="执行上下文-参考-ecma2024" tabindex="-1">执行上下文（参考 ECMA2024） <a class="header-anchor" href="#执行上下文-参考-ecma2024" aria-label="Permalink to &quot;执行上下文（参考 ECMA2024）&quot;">​</a></h1><h2 id="全局对象" tabindex="-1">全局对象 <a class="header-anchor" href="#全局对象" aria-label="Permalink to &quot;全局对象&quot;">​</a></h2><p><a href="https://262.ecma-international.org/#sec-global-object" target="_blank" rel="noreferrer">https://262.ecma-international.org/#sec-global-object</a></p><blockquote><p>The global object:</p><ul><li>is created before control enters any <a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">execution context</a> .</li><li>does not have a [[Construct]] internal method; it cannot be used as a <a href="https://262.ecma-international.org/#constructor" target="_blank" rel="noreferrer">constructor</a> with the <code>**new**</code> operator.</li><li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li><li>has a [[Prototype]] internal slot whose value is <a href="https://262.ecma-international.org/#host-defined" target="_blank" rel="noreferrer">host-defined</a>.</li><li>may have <a href="https://262.ecma-international.org/#host-defined" target="_blank" rel="noreferrer">host-defined</a> properties in addition to the properties defined in this specification. This may include a property whose value is the global object itself.</li></ul></blockquote><p>翻译：</p><blockquote><ul><li>全局对象是控制器 control 进入任何<strong>执行上下文</strong>之前创建 - 创建时机</li><li>没有[[Construct]]内部方法，因此不能与 new 操作符一起用作构造函数。</li><li>没有[[call]]内部方法，不能作为函数调用。</li><li>宿主环境可以自定义全局对象的原型数据</li><li>除了本规范中定义的属性外，全局对象还可以有宿主环境定义的属性。 这可能包括一个属性，其值就是全局对象本身。（浏览器 window）</li></ul></blockquote><p>重点：</p><p>创建时机在进入任何<strong>执行上下文</strong>之前；</p><p>全局对象还可以有宿主环境定义的属性；（内置 API、window）</p><p>理解：</p><p>V8 会在真正开始执行 javascript 代码前，会初始化 js 运行所需要的基础环境，<code>堆、栈空间</code>、<code>全局执行上下文</code>、<code>事件循环系统</code>等</p><p>在进入全局执行上下文之前，全局对象会被创建。</p><p>伪代码</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GlobalObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  String,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Array,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Date,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Settimeout</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>执行上下文是什么？</p></div><h2 id="执行上下文-execution-context-执行上下文栈-ecs" tabindex="-1">执行上下文 Execution Context &amp; 执行上下文栈 ECS <a class="header-anchor" href="#执行上下文-execution-context-执行上下文栈-ecs" aria-label="Permalink to &quot;执行上下文 Execution Context &amp; 执行上下文栈 ECS&quot;">​</a></h2><p><a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">https://262.ecma-international.org/#sec-execution-contexts</a></p><blockquote><p>An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation.</p><p>执行上下文 是一个规范设备，用于跟踪 ECMAScript 实现对代码的运行时评估。</p></blockquote><blockquote><p>An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for ECMAScript code to directly access or observe an execution context.</p><p>执行上下文纯粹是一个规范机制，不需要对应于 ECMAScript 实现的任何特定制品。ECMAScript 代码不可能直接访问或观察到执行上下文。</p></blockquote><blockquote><p>The execution context stack is used to track execution contexts. The <a href="https://262.ecma-international.org/#running-execution-context" target="_blank" rel="noreferrer">running execution context</a> is always the top element of this stack.</p><p>执行上下文堆栈 用于跟踪执行上下文。<a href="https://ecma262.com/2024/#running-execution-context" target="_blank" rel="noreferrer">正在运行的执行上下文</a> 始终是该堆栈的顶部元素。</p></blockquote><blockquote><p>A new execution context is created whenever control is transferred from the executable code associated with the currently <a href="https://262.ecma-international.org/15.0/index.html?_gl=1*qxsvcj*_ga*MzQwMjYwNjQxLjE3MzMyMDU5NjU.*_ga_TDCK4DWEPP*MTczMzIwNTk2NC4xLjEuMTczMzIwNzAxMC4wLjAuMA..#running-execution-context" target="_blank" rel="noreferrer">running execution context</a> to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the <a href="https://262.ecma-international.org/15.0/index.html?_gl=1*qxsvcj*_ga*MzQwMjYwNjQxLjE3MzMyMDU5NjU.*_ga_TDCK4DWEPP*MTczMzIwNTk2NC4xLjEuMTczMzIwNzAxMC4wLjAuMA..#running-execution-context" target="_blank" rel="noreferrer">running execution context</a>.</p><p>每当控制权从与当前运行的执行上下文相关联的可执行代码转移到与该执行上下文无关的可执行代码时，就会创建一个新的执行上下文。 新创建的执行上下文被推入堆栈，成为运行中的执行上下文。-- <strong>执行上下文的创建</strong></p></blockquote><h3 id="理解-ec、ecs" tabindex="-1">理解 EC、ECS <a class="header-anchor" href="#理解-ec、ecs" aria-label="Permalink to &quot;理解 EC、ECS&quot;">​</a></h3><p>执行上下文是在我们执行可执行文件时创建的 - 抽象概念</p><p>执行上下文栈，控制的执行上下文的状态的栈结构，从最<a href="about:blank" target="_blank" rel="noreferrer">新的 ECMA 规范</a>理解：</p><ul><li>执行上下文栈是用来跟踪执行上下文的，当前处于栈顶的是正在运行的执行上下文</li><li>调用其他关联的可执行代码时，会创建一个新的执行上下文，并将这个新的执行上下文压入栈顶</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>正如我们每次在执行函数前，都会创建函数执行上下文，当函数执行时，此执行上下文是处于调用栈顶部。执行完成后，这个函数的执行上下文就会被干掉。</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在某个特定的时刻 只能执行特定的代码。一旦发生函数调用，当前的执行上下文必须停止 执行，并创建新的函数执行上下文来执行函数。当函数执行完成后，将 函数执行上下文销毁，并重新回到发生调用时的执行上下文中。所以需 要跟踪执行上下文——正在执行的上下文以及正在等待的上下文。最简 单的跟踪方法是使用执行上下文栈(或称为调用栈)。 -- js 忍者秘籍</p></div><h3 id="执行上下文类型" tabindex="-1">执行上下文类型 <a class="header-anchor" href="#执行上下文类型" aria-label="Permalink to &quot;执行上下文类型&quot;">​</a></h3><ul><li><strong>全局执行上下文（ GEC）</strong> ：不在任何函数中的代码都位于全局执行上下文中，只有一个，当 JavaScript 程序开始执行时就已经创建了全局上下文。</li><li><strong>函数执行上下文（ FEC）</strong> ：<strong>只有调用</strong>函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤。</li><li><strong>Eval 函数执行上下文（eval 代码）</strong> ： 指的是运行在 <code>eval</code> 函数中的代码，很少使用。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>已经了解了 EC 是什么、以及它的类型，那么对于一个 EC 而言，它的内部结构是怎样的？</p></div><h3 id="执行上下文的内部结构" tabindex="-1">执行上下文的内部结构 <a class="header-anchor" href="#执行上下文的内部结构" aria-label="Permalink to &quot;执行上下文的内部结构&quot;">​</a></h3><blockquote><p>可以简单理解，一个执行上下文结构内部会包含一系列的组件，这些组件在执行上下文执行过程中有不同的作用</p></blockquote><p><em>ECMAScript 代码执行上下文的组件：</em></p><table tabindex="0"><thead><tr><th>Component</th><th>Purpose</th></tr></thead><tbody><tr><td>code evaluation state</td><td>Any state needed to perform, suspend, and resume evaluation of the code associated with this <a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">execution context</a><br>执行、暂停和恢复与此 <a href="https://ecma262.com/2024/#sec-execution-contexts" target="_blank" rel="noreferrer">执行上下文</a> 关联的代码所需的任何状态。</td></tr><tr><td>Function</td><td>If this <a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">execution context</a> is evaluating the code of a <a href="https://262.ecma-international.org/#function-object" target="_blank" rel="noreferrer">function object</a>，then the value of this component is that <a href="https://262.ecma-international.org/#function-object" target="_blank" rel="noreferrer">function object</a>. If the context is evaluating the code of a <a href="https://262.ecma-international.org/#prod-Script" target="_blank" rel="noreferrer"><em>Script</em></a>_ _or <a href="https://262.ecma-international.org/#prod-Module" target="_blank" rel="noreferrer">_Module_</a>, the value is <strong>null</strong>.<br>如果这个执行上下文评估的是函数对象的代码，那么这个组件的值是该函数对象。如果执行的是 Script 和 Module，这个值是 null</td></tr><tr><td><a href="https://262.ecma-international.org/#realm" target="_blank" rel="noreferrer">Realm</a></td><td>The <a href="https://262.ecma-international.org/#realm-record" target="_blank" rel="noreferrer">Realm Record</a> from which associated code accesses ECMAScript resources.<br>关联代码访问 ECMAScript 资源的领域记录<br>在代码运行之前，所有 ECMAScript 代码都必须与一个领域相关联。 从概念上讲，一个领域包括一组内置对象、一个 ECMAScript 全局环境、在该全局环境范围内加载的所有 ECMAScript 代码，以及其他相关状态和资源。</td></tr><tr><td>ScriptOrModule</td><td>The <a href="https://262.ecma-international.org/#sec-abstract-module-records" target="_blank" rel="noreferrer">Module Record</a> or <a href="https://262.ecma-international.org/#script-record" target="_blank" rel="noreferrer">Script Record</a> from which associated code originates. If there is no originating script or module, as is the case for the original <a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">execution context</a> created in <a href="https://262.ecma-international.org/#sec-initializehostdefinedrealm" target="_blank" rel="noreferrer">InitializeHostDefinedRealm</a>, the value is <strong>null</strong>.</td></tr><tr><td>LexicalEnvironment</td><td>Identifies the <a href="https://262.ecma-international.org/#sec-environment-records" target="_blank" rel="noreferrer">Environment Record</a> used to resolve identifier references made by code within this <a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">execution context</a>.<br>识别 环境记录，用于解析此执行上下文中代码对标识符的引用。</td></tr><tr><td>VariableEnvironment</td><td>Identifies the <a href="https://262.ecma-international.org/#sec-environment-records" target="_blank" rel="noreferrer">Environment Record</a> that holds bindings created by <a href="https://262.ecma-international.org/#prod-VariableStatement" target="_blank" rel="noreferrer"><em>VariableStatement</em></a>s within this <a href="https://262.ecma-international.org/#sec-execution-contexts" target="_blank" rel="noreferrer">execution context</a>.<br>用于标识环境记录，该环境记录保存由该执行上下文中的 VariableStatements 创建的绑定。<br>VariableStatements: <strong>var 声明的变量</strong></td></tr><tr><td>PrivateEnvironment</td><td>Identifies the <a href="https://262.ecma-international.org/#privateenvironment-record" target="_blank" rel="noreferrer">PrivateEnvironment Record</a> that holds <a href="https://262.ecma-international.org/#sec-private-names" target="_blank" rel="noreferrer">Private Names</a> created by <a href="https://262.ecma-international.org/#prod-ClassElement" target="_blank" rel="noreferrer"><em>ClassElement</em></a>s in the nearest containing class. <strong>null</strong> if there is no containing class.</td></tr></tbody></table><h4 id="伪代码理解-ec-内部结构" tabindex="-1">伪代码理解 EC 内部结构 <a class="header-anchor" href="#伪代码理解-ec-内部结构" aria-label="Permalink to &quot;伪代码理解 EC 内部结构&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    codeEvaluationState,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行上下文在执行栈的状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Function,             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行的是函数时，值为函数对象，其他的都是null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Realm,                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 领域：有一种全局环境的感觉</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    LexicalEnviroment: {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这块文档描述感觉不太清晰，理解不了。参考博客别的大佬理解的，暂且理解为非var声明的变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    VariableEnvironment: {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该执行上下文中的VariableStatements</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PrivateEnvironment: {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类的话，暂时先不理解，熟悉后可以画类的内存图看看</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Generator: {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>重点理解关注的组件：</p><p>Function 函数</p><ul><li>当前执行上下文是函数执行上下文时（评估函数对象代码的理解），值为函数对象，其他的都是 null</li></ul><p>LexicalEnviroment 词法环境</p><ul><li>官方描述实在没理解，有大佬明白的可以交流下</li><li>从其他文章看的：暂时过渡下 一般是<code>let</code>, <code>const</code> 声明的变量存储在该词法环境中，我理解是可以从词法环境的环境记录中找到<code>非var标识符</code>对应的映射值</li></ul><p>VariableEnvironment 变量环境</p><ul><li>VariableStatements <code>var</code>声明的变量可在<code>变量环境</code>的环境记录中找到对应的映射值</li></ul><blockquote><p>The LexicalEnvironment and VariableEnvironment components of an execution context are always <a href="https://262.ecma-international.org/15.0/index.html?_gl=1*qxsvcj*_ga*MzQwMjYwNjQxLjE3MzMyMDU5NjU.*_ga_TDCK4DWEPP*MTczMzIwNTk2NC4xLjEuMTczMzIwNzAxMC4wLjAuMA..#sec-environment-records" target="_blank" rel="noreferrer">Environment Records</a>.</p><p>执行上下文中的 LexicalEnvironment 和 VariableEnvironment 组件始终是<strong>环境记录</strong>。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>到此，我们已经对 EC 有一个大概的认知，也知道重点组件词法环境、变量环境其实就是是环境记录。那么什么是环境记录，怎么理解？</p></div>`,45)]))}const g=t(r,[["render",s]]);export{k as __pageData,g as default};
